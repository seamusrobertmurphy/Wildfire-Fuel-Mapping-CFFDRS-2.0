---
title: "Proof of Concept:"
subtitle: "CFFDRS Wildfire Fuel Mapping Prototype"
author: "CabinGIS"
date: "24/02/2022"
output: 
  pdf_document:
    toc: TRUE
    toc_depth: 4
    number_sections: TRUE
    df_print: tibble
    latex_engine: xelatex
  zotero: TRUE
bibliography: references.bib
---

```{r setup, echo=FALSE, message=FALSE,warning=FALSE, error=FALSE}
library(lidR)
library(mapview)
library(rgl)
library(pandocfilters)
library(rmarkdown)
library(formatR)
library(gitignore)
library(tinytex)
library(knitr)
library(raster)
library(webdriver)
library(webshot)
library(webshot2)
library(RColorBrewer)
library(conflicted)
library(readr)
library(tibble)
library(grid)
library(sf)
library(dplyr)
library(raster)
library(terra)
library(rgdal)
library(utils)
library(cffdrs)
library(ncdf4)
library(elevatr)
library(ggplot2)
library(ggmap)
library(latticeExtra)
library(rasterVis)
library(curl)
library(tmap)
library(tmaptools)
#webshot::install_phantomjs(force = TRUE)
knit_hooks$set(webgl = hook_webgl)
knit_hooks$set(rgl.static = hook_rgl)
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, error=FALSE, message = FALSE)
set.seed(23)
```

## Action {.unnumbered}

Building on the momentum and ideas of our last meeting, the following pipeline was attempted to produce the wildfire fuel mapping outputs described in the NRC grant "High-Resolution Mapping":

-   NRC Grant: <https://www.ic.gc.ca/eic/site/101.nsf/eng/00157.html>

Using the new [cffdrs R-package](https://cran.r-project.org/web/packages/cffdrs/cffdrs.pdf) (\@wang2017cffdrs; \@van1985equations; \@van1987development), we developed rasters of forest fuel moisture code and wildfire weather indices (Table 1) that were used to fit the stand-adjusted fine-fuel model (\@wotton2007stand) applied to vegetation rasters classified according to 16 fuel classes of the BC forest fuel typing algorithm ( \@perrakis2018british). REeult rasters were then used to fit the Canadian Forest Fire Behaviour Prediction model from which we drafted raster maps representing Head Fire Index (HFI) and Fire Intensity maps (FI) (Figure 1) for the Okanagan Watershed Basin for the day of June 30th 2021.

![](Data/CFFDRS%20Prototype.png)

Figure 1: Tentative Workflow

# Selecting AOI (Okanagan Watershed)

Two input options for selecting AOI were explored below: 1) uploading AOI boundary file and 2) choosing point location as centre of 10km LxW bounding box. For testing boundary file uploads, we downloaded the Okanagan Watershed boundary (FWA ID:212) from the BC Geographic Warehouse which was extracted from the BC Freshwater Atlas Dataset. The aoi feature layer was imported as a simple feature and transformed into sp and spatVector objects for different processing and compatability options. From this initial scoping exercise, the terra route looks like a powerful pipeline (sf \> terra \> ggmap \> elevatr = tmap/gplot).

```{r}
watershed_okanagan_sf = st_read("./Data/watershed-okanagan-QX.shp")
watershed_okanagan_sp = sf:::as_Spatial(watershed_okanagan_sf) 
watershed_okanagan_sv = vect(watershed_okanagan_sf)
ggplot(watershed_okanagan_sf) + geom_sf(alpha=0.1) + coord_sf()
```

# Importing Basemaps: Google Cloud Api

For potential GUI-widgets and tools, we tested potential base mapping services from [Google Cloud API](https://cloud.google.com/maps-platform/) using the ggmap package and a free API key token set up with personal google account. These required latitude-longitude coordinates as inputs. All data layers were projected to match the Google Pseudo Mercator (EPSG:3857) and then reprojected to CSRS EPSG:3153 for metric analyses. Four basemaps were tested using the API server at a zoom setting of 8 and a latitude and longitude location of -119, 50.0. Still some kinks to work out with the point location input, though seems point of interest is more compatability to the NASA Power APIs.

```{r}

gmap = get_map(location = c(-119.7, 50.0), maptype = "hybrid", source = "google", crop = FALSE, zoom = 8)
gmap1 = ggmap(get_map(location = c(-119.7, 50.0), maptype = "satellite", source = "google", zoom = 8))
gmap2 = ggmap(get_map(location = c(-119.7, 50.0), maptype = "toner-lite", zoom = 8))
gmap3 = ggmap(get_map(location = c(-119.7, 50.0), maptype = "toner-background", zoom = 8))
gmap4 = ggmap(get_map(location = c(-119.7, 50.0), mqptype="terrain-labels", zoom = 8))
```

<img src="Data/basemap_gmap0.png" width="350"/>

<img src="Data/basemap_gmap2.png" width="350"/>

<img src="Data/basemap_gmap3.png" width="350"/>

<img src="Data/basemap_gmap4.png" width="350"/>

For manipulating the default 'satellite' basemap layers and overlaying user's aoi boundary, we used Lobo's script [(2014)](https://rstudio-pubs-static.s3.amazonaws.com/16660_7d1ab1b355344578bbacb0747fd485c8.html) to transform the RGB object from a matrix to a rasterbrick to SpatRaster before applying cartography. The 'Google Pseudo Mercator' (epsg:3857) seems the likely projection used but not much information available on this online. Perhaps more accuracy assessments required in any potential grant objectives. FYI, these chunk outputs take up a good bit of system memory and may cause crashes. For sake of word count, top gmap(1) object was repeated for each gmap output.

```{r, eval=FALSE}
mgmap <- as.matrix(gmap)
vgmap <- as.vector(mgmap)
vgmaprgb <- col2rgb(vgmap)
gmapr <- matrix(vgmaprgb[1, ], ncol = ncol(mgmap), nrow = nrow(mgmap))
gmapg <- matrix(vgmaprgb[2, ], ncol = ncol(mgmap), nrow = nrow(mgmap))
gmapb <- matrix(vgmaprgb[3, ], ncol = ncol(mgmap), nrow = nrow(mgmap))
rgmaprgbGM <- brick(raster(gmapr), raster(gmapg), raster(gmapb))
rm(gmapr, gmapg, gmapb)
raster::projection(rgmaprgbGM) <- CRS("+init=epsg:3857")
# align crs grids
unlist(attr(gmap, which = "bb"))[c(2, 4, 1, 3)]
rprobextSpDF <- as(extent(unlist(attr(gmap, which = "bb"))[c(2, 4, 1, 3)]), "SpatialPolygons")
raster::projection(rprobextSpDF) <- CRS("+init=epsg:4326")
rprobextGM <- spTransform(rprobextSpDF, CRS("+init=epsg:3857"))
rprobextGM@bbox
extent(rgmaprgbGM) <- c(rprobextGM@bbox[1, ], rprobextGM@bbox[2, ])
plotRGB(rgmaprgbGM)
writeRaster(rgmaprgbGM, file = "./Data/rgmaprgbGM.tif", format = "GTiff", overwrite = TRUE, datatype = "INT1U")
watershed_okanagan_sp <- spTransform(watershed_okanagan_sp, CRS("+init=epsg:3857"))
gmap_rast = rast(rgmaprgbGM)
RGB(gmap_rast) = c(1,2,3)
plot(gmap_rast)
crs(watershed_okanagan_sv) = "EPSG:3857"
st_transform(watershed_okanagan_sf, 3857)
tm_shape(gmap_rast)+
  tm_rgb(alpha=0.9)+
  tm_shape(watershed_okanagan_sf)+
  tm_borders(col="yellow") +
  tm_compass(type = "8star", position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 50, 100, 200), text.size = 0.5)+
  tm_grid()
```

# Importing Elevation Data

LiDAR data at a resolution of 3-arc seconds was acquired using the 'elevatr' package. As far as I could find, this package provides one of the few remaining free sources of the SRTM dataset pre-processed at this resolution due to their the continuing Mapzen license (\@van2001shuttle). DEM data was transformed into a spatRaster and disaggreated from 98m resolution fown to 32m\~ resolution. Slope and aspect rasters were calculated using the terra::terrain function with a bilinear interpolation and a rook neighbourhood sampling of 8 adjacent cells. This produced problematic results and the raster processing approach was oapplied using the deprecated slopeAspect functions.

```{r, fig.show='hold', out.width="33%"}
ELV = get_elev_raster(watershed_okanagan, z=8)
#raster::projection(ELV) <- CRS("+init=epsg:3857")
GS = slopeAspect(ELV, filename = "./Data/GS.tif", 
  out='aspect', unit='degrees', neighbors=8, overwrite=TRUE)
GS = raster("./Data/GS.tif")
GS = rast(GS)
Aspect = slopeAspect(ELV, filename = "./Data/Aspect.tif", 
  out='slope', unit='degrees', neighbors=8, overwrite=TRUE)  
Aspect = raster("./Data/Aspect.tif")
Aspect = rast(Aspect)
ELV = rast(ELV)
ELV = disagg(ELV, fact=3.3)
GS = resample(GS, ELV, method="bilinear")
Aspect = resample(Aspect, ELV, method="bilinear")
Aspect = mask(Aspect, vect(watershed_okanagan))
GS = mask(GS, vect(watershed_okanagan))
ELV = mask(ELV, vect(watershed_okanagan))
plot(GS, main='slope')
plot(ELV, main='elevation')
plot(Aspect, main='aspect')
```

# Importing Climate Data

Climate variables were downloaded as NetCDF files from NASA Power platform and read directly into R as rasters of 1) mean daily temperature at 2m, 2) mean daily precipitation, 3) mean relative humidity, 4) and mean wind speed at 10m. The NASA Power platform supports some very user-friendly API links for static data sources that might be useful for this proposed grant project. REminder tho, some API's prefer dealing with dataframe inputs so might be worht preparing df pipe while still fresh in the head.

-   NASA Power Platform: <https://power.larc.nasa.gov/data-access-viewer/>

```{r, fig.show='hold', out.width="50%"}
temp = terra::rast("./Data/temp.nc")
prec = terra::rast("./Data/prec.nc")
rh = terra::rast("./Data/rh.nc")
ws = terra::rast("./Data/ws.nc")
temp = mask(temp, vect(watershed_okanagan))
prec = mask(prec, vect(watershed_okanagan))
rh = mask(rh, vect(watershed_okanagan))
ws = mask(ws, vect(watershed_okanagan))
temp = mean(temp)
prec = mean(prec)
rh = mean(rh)
ws = mean(ws)
names(temp) = 'temp'
names(prec) = 'prec'
names(rh) = 'rh'
names(ws) = 'ws'
plot(temp, main='temperature (2m)')
plot(prec, main='precipitation (mm/day)')
plot(rh, main='relative humidity')
plot(ws, main='wind speed (10m)')
#temp = terra::resample(temp, ELV, method="bilinear")
#prec = terra::resample(prec, ELV, method="bilinear")
#rh = terra::resample(rh, ELV, method="bilinear")
#ws = terra::resample(ws, ELV, method="bilinear")
```

# Importing VRI Data

The VRI dataset was downloaded from imapBC as a shapefile.shp and transformed into simple feature for processing oeprations using sf and dplyr functions. For CFFDRS data requirements, we consulted the two package-provied sample datasets 'test_fwi' and 'test_fpb' presented below:

```{r}
library(cffdrs)
print(as_tibble(test_fwi), n = 10)
print(as_tibble(test_fbp), n = 10)
```

Wotton and Beverly's model of stand-adjusted fine fuel moisture content requires five predictor variables, two of which were extracted directly from spatial layers of the the VRI dataset including stand-type ('SPEC_CD_1 ==?' & 'SPEC_PCT_1 \> 0.80)BCLCS_LV_1,

```{r, fig.show='hold', out.width="50%", eval=FALSE}
vri2020_sf = st_read("./Data/BCGW_7113060B_1645786298548_3276/VEG_COMP_LYR_R1_POLY/VEG_R1_PLY_polygon.shp")
st_crs(watershed_okanagan) = 3005
vri2020_sf = st_intersection(st_make_valid(vri2020_sf), watershed_okanagan)
str(vri2020_sf)

fuel_attributes = vri2020_sf %>%
  dplyr::select(BCLCS_LV_1, BCLCS_LV_2, BCLCS_LV_3, BCLCS_LV_4, BCLCS_LV_5, SHRB_HT, SHRB_CC, HERB_TYPE, HERB_COVER, HERB_PCT, NON_VEG_1, BEC_ZONE, BEC_SZONE, N_LOG_DATE, DEAD_PCT, HRVSTDT, SITE_INDEX, SPEC_CD_1, SPEC_CD_2, SPEC_PCT_1, SPEC_PCT_2, PROJ_HT_1, SPEC_AGE_1, DEAD_PCT, STEM_HA_CD, DEAD_STEMS, NVEG_COV_1)

library(dplyr)
Wotton_fuel_N = 0
Wotton_fuel_decid = 1
Wotton_fuel_Df = 2
Wotton_fuel_MW = 3
Wotton_fuel_PI = 4
Wotton_fuel_SP = 5

Wotton_fuel_class = vri2020_sf%>% 
  mutate(fuel_type = case_when((BCLCS_LV_1 == "N") ~ 0,
  (BCLCS_LV_1 == "V" & BCLCS_LV_4 = "TB") ~ 1,
  (BCLCS_LV_1 == "V" & SPEC_CD_1 == "FD" | SPEC_CD_1 == "FDC" | SPEC_CD_1 == "FDI") ~ 2,
  (BCLCS_LV_1 == "V" & SPEC_PCT_1 <= 80) ~ 3,
  (BCLCS_LV_1 == "V" & SPEC_CD_1 == "PA" | SPEC_CD_1 == "PL" | SPEC_CD_1 == "PLC" | SPEC_CD_1 == "PY") ~ 4,
  (BCLCS_LV_1 == "V" & BCLCS_LV_5 =="SP" | SPEC_CD_1 == "SB" | SPEC_CD_1 == "SX" | SPEC_CD_1 == "SW" | SPEC_CD_1 == "S" | BEC_ZONE == "BWBS" | BEC_ZONE == "SWB") ~ 5,
  TRUE ~ 0))


density = vri_sf["LIVE_STEMS"] %>% mutate(LIVE_STEMS = as.numeric(LIVE_STEMS))
density = rename(density, density = LIVE_STEMS)
ggplot(stand) + geom_sf(aes(fill=stand), size = 0.05)
ggplot(density) + geom_sf(aes(fill=density), size = 0.0005) + scale_fill_viridis_c()
```

```{r, eval=FALSE}

#### *fwiRaster and sdmc calculated based on daily climate records*

#### *gfmc and hffmc calculated based on hourly climate records - key to CFFDRSv2.0*

#### *Start date of fire season calculated with fireSeason*

#### *All outputs generated for once-daily calcuylations for the full fireSeason chronologically using 'batch=TRUE' function*

```

# Generating CFFDRS Wildfire Weather Maps

Interpolated climate predictors were assembled as a raster stack and inputted into the fwiRaster function. The 'out="all'" option was applied to produce additional outputs representing for Initial Spread Index (isi), and Build-up Index (bui).

```{r}
temp = raster::raster(temp)
prec = raster::raster(prec)
rh = raster::raster(rh)
ws = raster::raster(ws)
stack = stack(temp, rh, ws, prec)
names(stack)
fwi_outputs = fwiRaster(stack, out = "all")
plot(fwi_outputs)
ffmc = raster(fwi_outputs, layer=5)
dmc = raster(fwi_outputs, layer=6)
dc = raster(fwi_outputs, layer=7)
isi = raster(fwi_outputs, layer=8)
bui = raster(fwi_outputs, layer=9)
fwi = raster(fwi_outputs, layer=10)
dsr = raster(fwi_outputs, layer=11)
```
