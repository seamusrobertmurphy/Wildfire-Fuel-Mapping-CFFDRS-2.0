---
title: "Proof of Concept:"
subtitle: "CFFDRS Wildfire Fuel Mapping Prototype"
author: "CabinGIS"
date: "24/02/2022"
output: 
  pdf_document:
    toc: TRUE
    toc_depth: 4
    number_sections: TRUE
    df_print: tibble
    latex_engine: xelatex
  zotero: TRUE
bibliography: references.bib
---

```{r setup, echo=FALSE, message=FALSE,warning=FALSE, error=FALSE}
library(devtools)
library(lidR)
library(mapview)
library(rgl)
library(pandocfilters)
library(rmarkdown)
library(formatR)
library(gitignore)
library(tinytex)
library(knitr)
library(raster)
library(webdriver)
library(webshot)
library(RColorBrewer)
library(conflicted)
library(readr)
library(tibble)
library(grid)
library(sf)
library(dplyr)
library(raster)
library(terra)
library(rgdal)
library(utils)
library(cffdrs)
library(ncdf4)
library(elevatr)
library(ggplot2)
library(ggmap)
library(latticeExtra)
library(rasterVis)
library(curl)
library(tmap)
library(tmaptools)
webshot::install_phantomjs(force = TRUE)
knit_hooks$set(webgl = hook_webgl)
knit_hooks$set(rgl.static = hook_rgl)
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, error=FALSE, message = FALSE)
set.seed(23)
```

## Action {.unnumbered}

Building on the momentum and ideas of our last meeting, the following pipeline was attempted to produce the wildfire fuel mapping outputs described in the NRC grant "High-Resolution Mapping":

-   NRC Grant: <https://www.ic.gc.ca/eic/site/101.nsf/eng/00157.html>

Using the new [cffdrs R-package](https://cran.r-project.org/web/packages/cffdrs/cffdrs.pdf) (\@wang2017cffdrs; \@van1985equations; \@van1987development), we developed rasters of forest fuel moisture code and wildfire weather indices (Table 1) that were used to fit the stand-adjusted fine-fuel model (\@wotton2007stand) applied to vegetation rasters classified according to 16 fuel classes of the BC forest fuel typing algorithm ( \@perrakis2018british). REeult rasters were then used to fit the Canadian Forest Fire Behaviour Prediction model from which we drafted raster maps representing Head Fire Index (HFI) and Fire Intensity maps (FI) (Figure 1) for the Okanagan Watershed Basin for the day of June 30th 2021.

![](Data/CFFDRS%20Prototype.png)

Figure 1: Tentative Workflow

# User AOI

Two input options for selecting AOI were explored below: 1) uploading AOI boundary file and 2) choosing point location as centre of 10km LxW bounding box. For testing boundary file uploads, we downloaded the Okanagan Watershed boundary (FWA ID:212) from the BC Geographic Warehouse which was extracted from the BC Freshwater Atlas Dataset. The aoi feature layer was imported as a simple feature and transformed into sp and spatVector objects for different processing and compatability options. From this initial scoping exercise, the terra route looks like a powerful pipeline (sf \> terra \> ggmap \> elevatr = tmap/gplot), but still needs some figuring out to integrate with the APIs.

```{r}
watershed_okanagan_sf = st_read("./Data/watershed-okanagan-QX.shp")
watershed_okanagan_sp = sf:::as_Spatial(watershed_okanagan_sf) 
watershed_okanagan_sv = vect(watershed_okanagan_sf)
ggplot(watershed_okanagan_sf) + geom_sf(alpha=0.1) + coord_sf()
```

# Basemaps: Google Cloud Api

For potential GUI-widgets and tools, we tested potential base mapping services from [Google Cloud API](https://cloud.google.com/maps-platform/) using the ggmap package and a free API key token set up with personal google account. These required latitude-longitude coordinates as inputs. All data layers were projected to match the Google Pseudo Mercator (EPSG:3857) and then reprojected to CSRS EPSG:3153 for metric analyses. Four basemaps were tested using the API server at a zoom setting of 8 and a latitude and longitude location of -119, 50.0. Still some kinks to work out with the point location input, though seems that this point of interest route is more compatible, especially for working with NASA Power APIs.

```{r}
register_google(key = 'AIzaSyDbjpyUjJp3VInMOqebU9yp2zff5hA-zBM')
gmap = get_map(location = c(-119.7, 50.0), maptype = "hybrid", source = "google", crop = FALSE, zoom = 8)
gmap1 = ggmap(get_map(location = c(-119.7, 50.0), maptype = "satellite", source = "google", zoom = 8))
gmap2 = ggmap(get_map(location = c(-119.7, 50.0), maptype = "toner-lite", zoom = 8))
gmap3 = ggmap(get_map(location = c(-119.7, 50.0), maptype = "toner-background", zoom = 8))
gmap4 = ggmap(get_map(location = c(-119.7, 50.0), mqptype="terrain-labels", zoom = 8))
```

<img src="Data/basemap_gmap0.png" width="350"/>

<img src="Data/basemap_gmap2.png" width="350"/>

<img src="Data/basemap_gmap3.png" width="350"/>

<img src="Data/basemap_gmap4.png" width="350"/>

For manipulating the default 'satellite' basemap layers and overlaying user's aoi boundary, we used Lobo's script [(2014)](https://rstudio-pubs-static.s3.amazonaws.com/16660_7d1ab1b355344578bbacb0747fd485c8.html) to transform the RGB object from a matrix to a rasterbrick to SpatRaster before applying cartography. The 'Google Pseudo Mercator' (epsg:3857) seems the likely projection used but not much information available on this online. Perhaps more accuracy assessments required in any potential grant objectives. FYI, these chunk outputs take up a good bit of system memory and may cause crashes. For sake of word count, top gmap(1) object was repeated for each gmap output.

```{r, eval=FALSE}
mgmap <- as.matrix(gmap)
vgmap <- as.vector(mgmap)
vgmaprgb <- col2rgb(vgmap)
gmapr <- matrix(vgmaprgb[1, ], ncol = ncol(mgmap), nrow = nrow(mgmap))
gmapg <- matrix(vgmaprgb[2, ], ncol = ncol(mgmap), nrow = nrow(mgmap))
gmapb <- matrix(vgmaprgb[3, ], ncol = ncol(mgmap), nrow = nrow(mgmap))
rgmaprgbGM <- brick(raster(gmapr), raster(gmapg), raster(gmapb))
rm(gmapr, gmapg, gmapb)
raster::projection(rgmaprgbGM) <- CRS("+init=epsg:3857")
# align crs grids
unlist(attr(gmap, which = "bb"))[c(2, 4, 1, 3)]
rprobextSpDF <- as(extent(unlist(attr(gmap, which = "bb"))[c(2, 4, 1, 3)]), "SpatialPolygons")
raster::projection(rprobextSpDF) <- CRS("+init=epsg:4326")
rprobextGM <- spTransform(rprobextSpDF, CRS("+init=epsg:3857"))
rprobextGM@bbox
extent(rgmaprgbGM) <- c(rprobextGM@bbox[1, ], rprobextGM@bbox[2, ])
plotRGB(rgmaprgbGM)
writeRaster(rgmaprgbGM, file = "./Data/rgmaprgbGM.tif", format = "GTiff", overwrite = TRUE, datatype = "INT1U")
#watershed_okanagan_sp <- spTransform(watershed_okanagan_sp, CRS("+init=epsg:3857"))

gmap_rast = rast(rgmaprgbGM)
RGB(gmap_rast) = c(1,2,3)
crs(gmap_rast) = "EPSG:3857"
crs(watershed_okanagan_sv) = "EPSG:3857"
st_transform(watershed_okanagan_sf, 3857)
# plot objects locally
tm_shape(gmap_rast)+
  tm_rgb(alpha=0.8)+
  tm_shape(watershed_okanagan_sf)+
  tm_borders(col="yellow") +
  tm_compass(type = "8star", position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 50, 100, 200), text.size = 0.8)+
  tm_grid()
```

![](Data/basemap_gmap_overlay.png)

# Importing Elevation Data

LiDAR data at a resolution of 3 arc seconds was acquired using the 'elevatr' package. As far as we could find, this is one of the few remaining free sources of the SRTM dataset pre-processed at this resolution. It uses their the continuing Mapzen license (\@van2001shuttle). DEM data was transformed into a spatRaster and disaggreated from 98m resolution fown to 32m\~ resolution. Slope and aspect tasters were calculated using the terra::terrain function with a bilinear interpolation and a rook neighbourhood sampling of 8 adjacent cells. This produced problematic results and the raster processing approach was applied using the deprecated 'slopeAspect' function.

```{r, fig.show='hold', out.width="33%", eval=FALSE}
ELV = get_elev_raster(watershed_okanagan_sf, z=8)
GS = slopeAspect(ELV, filename = "./Data/GS.tif", 
  out='slope', unit='degrees', neighbors=8, overwrite=TRUE)
Aspect = slopeAspect(ELV, filename = "./Data/Aspect.tif", 
  out='aspect', unit='degrees', neighbors=8, overwrite=TRUE)  
writeRaster(ELV, file = "./Data/ELV", format = "GTiff", overwrite = TRUE, datatype = "INT1U")
raster::projection(ELV) <- CRS("+init=epsg:3857")
raster::projection(GS) <- CRS("+init=epsg:3857")
raster::projection(Aspect) <- CRS("+init=epsg:3857")
ELV_sr = rast(ELV)
GS_sr = rast(GS)
Aspect_sr = rast(Aspect)
crs(ELV_sr) = "EPSG:3857"
crs(GS_sr) = "EPSG:3857"
crs(Aspect_sr) = "EPSG:3857"
ELV_sr = disagg(ELV_sr, fact=6.8)
GS_sr = resample(GS_sr, ELV_sr, method="bilinear")
Aspect_sr = resample(Aspect_sr, ELV_sr, method="bilinear")
ELV_sr = mask(ELV_sr, watershed_okanagan_sv)
GS_sr = mask(GS_sr, watershed_okanagan_sv)
Aspect_sr = mask(Aspect_sr, watershed_okanagan_sv)

#POI route
tm_shape(ELV)+
  tm_raster(style= "cont", title="Elevation ASL")+
  tm_layout(legend.outside = TRUE)+
  tm_shape(watershed_okanagan_sf)+
  tm_borders(col="black", lwd = 2) +
  tm_compass(type = "8star", position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 25, 50, 100), text.size = 0.5)+
  tm_grid()

tm_shape(GS)+
  tm_raster(style= "cont", title="Slope")+
  tm_layout(legend.outside = TRUE)+
  tm_shape(watershed_okanagan_sf)+
  tm_borders(col="black", lwd = 2) +
  tm_compass(type = "8star", position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 25, 50, 100), text.size = 0.5)+
  tm_grid()

tm_shape(Aspect)+
  tm_raster(style= "cont", title="Aspect")+
  tm_layout(legend.outside = TRUE)+
  tm_shape(watershed_okanagan_sf)+
  tm_borders(col="black", lwd = 2) +
  tm_compass(type = "8star", position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 25, 50, 100), text.size = 0.5)+
  tm_grid()

# AOI route
tm_shape(ELV_sr)+
  tm_raster(style= "cont", title="Elevation ASL")+
  tm_layout(legend.outside = TRUE)+
  tm_shape(watershed_okanagan_sf)+
  tm_borders(col="black", lwd = 2) +
  tm_compass(type = "8star", position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 25, 50, 100), text.size = 0.5)+
  tm_grid()

tm_shape(GS_sr)+
  tm_raster(style= "cont", title="Slope")+
  tm_layout(legend.outside = TRUE)+
  tm_shape(watershed_okanagan_sf)+
  tm_borders(col="black", lwd = 2) +
  tm_compass(type = "8star", position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 25, 50, 100), text.size = 0.5)+
  tm_grid()

tm_shape(Aspect_sr)+
  tm_raster(style= "cont", title="Aspect")+
  tm_layout(legend.outside = TRUE)+
  tm_shape(watershed_okanagan_sf)+
  tm_borders(col="black", lwd = 2) +
  tm_compass(type = "8star", position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 25, 50, 100), text.size = 0.5)+
  tm_grid()
```

# Importing Climate Data

Climate variables were downloaded as NetCDF data from NASA Power platform and read directly into R as spatRraster objects for 1) mean daily temperature at 2m, 2) mean daily precipitation, 3) mean relative humidity, 4) and mean wind speed at 10m. The NASA Power platform supports some very user-friendly API links for static data sources that might be useful for this proposed grant project. REminder tho, some API's prefer dealing with dataframe inputs so might be worht preparing df pipe while still fresh in the head.

-   NASA Power Platform: <https://power.larc.nasa.gov/data-access-viewer/>

```{r, fig.show='hold', out.width="50%", eval=FALSE}
temp = terra::rast('NETCDF:"./Data/temp.nc"')
prec = terra::rast('NETCDF:"./Data/precip.nc"')
rh = terra::rast('NETCDF:"./Data/rh.nc"')
ws = terra::rast('NETCDF:"./Data/ws.nc"')
temp = mean(temp)
prec = mean(prec)
rh = mean(rh)
ws = mean(ws)
names(temp) = 'temp'
names(prec) = 'prec'
names(rh) = 'rh'
names(ws) = 'ws'


crs(temp) = "EPSG:3857"
crs(prec) = "EPSG:3857"
crs(rh) = "EPSG:3857"
crs(ws) = "EPSG:3857"

temp_ext = ext(temp)

project(temp_ext, crs

temp_raster = raster(temp)
writeRaster(temp_raster, file = "./Data/temp.tif", format = "GTiff", overwrite = TRUE)


terra::project(temp, gmap_rast)


#raster::raster(temp)
#raster::raster(prec)
#raster::raster(rh)
#raster::raster(ws)
#raster::writeRaster(temp, file = "./Data/temp", format = "GTiff", overwrite = TRUE)

st_transform(watershed_okanagan_sf, crs = crs(temp))
tm_shape(temp)+
  tm_raster(style= "cont", title="Temperature (2m AGL)")+
  tm_layout(legend.outside = TRUE)+
  tm_shape(watershed_okanagan_sf)+
  tm_borders(col="black", lwd = 2) +
  tm_compass(type = "8star", position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 25, 50, 100), text.size = 0.5)+
  tm_grid()

```

# Importing VRI Data

The VRI dataset was downloaded from imapBC as a shapefile.shp and transformed into simple feature for processing oeprations using sf and dplyr functions. For CFFDRS data requirements, we consulted the two package-provied sample datasets 'test_fwi' and 'test_fpb' presented below:

```{r}
library(cffdrs)
print(as_tibble(test_fwi), n = 10)
print(as_tibble(test_fbp), n = 10)
```

Wotton and Beverly's model of stand-adjusted fine fuel moisture content requires five predictor variables, two of which were extracted directly from spatial layers of the the VRI dataset including stand-type ('SPEC_CD_1 ==?' & 'SPEC_PCT_1 \> 0.80)BCLCS_LV_1,

```{r, fig.show='hold', out.width="50%", eval=FALSE}
vri2020_sf = st_read("./Data/BCGW_7113060B_1645786298548_3276/VEG_COMP_LYR_R1_POLY/VEG_R1_PLY_polygon.shp")
st_crs(watershed_okanagan) = 3005
vri2020_sf = st_intersection(st_make_valid(vri2020_sf), watershed_okanagan)
str(vri2020_sf)

fuel_attributes = vri2020_sf %>%
  dplyr::select(BCLCS_LV_1, BCLCS_LV_2, BCLCS_LV_3, BCLCS_LV_4, BCLCS_LV_5, SHRB_HT, SHRB_CC, HERB_TYPE, HERB_COVER, HERB_PCT, NON_VEG_1, BEC_ZONE, BEC_SZONE, N_LOG_DATE, DEAD_PCT, HRVSTDT, SITE_INDEX, SPEC_CD_1, SPEC_CD_2, SPEC_PCT_1, SPEC_PCT_2, PROJ_HT_1, SPEC_AGE_1, DEAD_PCT, STEM_HA_CD, DEAD_STEMS, NVEG_COV_1)

library(dplyr)
Wotton_fuel_N = 0
Wotton_fuel_decid = 1
Wotton_fuel_Df = 2
Wotton_fuel_MW = 3
Wotton_fuel_PI = 4
Wotton_fuel_SP = 5

Wotton_fuel_class = vri2020_sf%>% 
  mutate(fuel_type = case_when((BCLCS_LV_1 == "N") ~ 0,
  (BCLCS_LV_1 == "V" & BCLCS_LV_4 = "TB") ~ 1,
  (BCLCS_LV_1 == "V" & SPEC_CD_1 == "FD" | SPEC_CD_1 == "FDC" | SPEC_CD_1 == "FDI") ~ 2,
  (BCLCS_LV_1 == "V" & SPEC_PCT_1 <= 80) ~ 3,
  (BCLCS_LV_1 == "V" & SPEC_CD_1 == "PA" | SPEC_CD_1 == "PL" | SPEC_CD_1 == "PLC" | SPEC_CD_1 == "PY") ~ 4,
  (BCLCS_LV_1 == "V" & BCLCS_LV_5 =="SP" | SPEC_CD_1 == "SB" | SPEC_CD_1 == "SX" | SPEC_CD_1 == "SW" | SPEC_CD_1 == "S" | BEC_ZONE == "BWBS" | BEC_ZONE == "SWB") ~ 5,
  TRUE ~ 0))


density = vri_sf["LIVE_STEMS"] %>% mutate(LIVE_STEMS = as.numeric(LIVE_STEMS))
density = rename(density, density = LIVE_STEMS)
ggplot(stand) + geom_sf(aes(fill=stand), size = 0.05)
ggplot(density) + geom_sf(aes(fill=density), size = 0.0005) + scale_fill_viridis_c()
```

```{r, eval=FALSE}

#### *fwiRaster and sdmc calculated based on daily climate records*

#### *gfmc and hffmc calculated based on hourly climate records - key to CFFDRSv2.0*

#### *Start date of fire season calculated with fireSeason*

#### *All outputs generated for once-daily calcuylations for the full fireSeason chronologically using 'batch=TRUE' function*

```

# Generating CFFDRS Wildfire Weather Maps

Interpolated climate predictors were assembled as a raster stack and inputted into the fwiRaster function. The 'out="all'" option was applied to produce additional outputs representing for Initial Spread Index (isi), and Build-up Index (bui).

```{r}
temp = raster::raster(temp)
prec = raster::raster(prec)
rh = raster::raster(rh)
ws = raster::raster(ws)
stack = stack(temp, rh, ws, prec)
names(stack)
fwi_outputs = fwiRaster(stack, out = "all")
plot(fwi_outputs)
ffmc = raster(fwi_outputs, layer=5)
dmc = raster(fwi_outputs, layer=6)
dc = raster(fwi_outputs, layer=7)
isi = raster(fwi_outputs, layer=8)
bui = raster(fwi_outputs, layer=9)
fwi = raster(fwi_outputs, layer=10)
dsr = raster(fwi_outputs, layer=11)
```
